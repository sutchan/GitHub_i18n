# 页面模式支持与性能优化

## 📋 概述

本文档详细介绍GitHub中文翻译插件中实现的页面模式支持和性能优化功能，包括核心方法的实现原理、优化策略以及使用说明。

## 📋 概述

本文档详细介绍GitHub中文翻译插件中实现的页面模式支持和性能优化功能，包括核心方法的实现原理、优化策略以及使用说明。

## 🔍 功能简介

## 页面模式支持

页面模式（pageMode）功能允许翻译引擎根据不同的GitHub页面类型（如issues/pullRequests、wiki、search、codespaces等）智能调整翻译行为，实现更精准的内容识别和更高效的翻译处理。

## 性能优化

通过引入缓存机制、优化DOM监听逻辑、实现页面模式特定的阈值和规则，显著提升了翻译引擎的性能和准确性，特别是在大型复杂页面上的表现。

## 🛠️ 核心实现

## 1. 多级缓存机制实现

## # 实现原理

多级缓存机制为不同类型的数据提供专门的缓存策略，显著提升性能：

```javascript

/**
 * 多级缓存管理器
 * /
class CacheManager {
  constructor() {
    // 元素重要性缓存 - 短期缓存
    this.importantElementCache = new Map();
    // 元素忽略缓存 - 短期缓存
    this.ignoreElementCache = new Map();
    // 翻译结果缓存 - 持久化缓存
    this.translationCache = new Map();
    // 页面模式配置缓存 - 会话级缓存
    this.pageModeConfigCache = new Map();
    // 缓存统计
    this.stats = {
      hits: 0,
      misses: 0
    };
  }

  /**
   * 获取缓存项
   * @param {Map} cache - 缓存Map
   * @param {string} key - 缓存键
   * @returns {*} - 缓存值
   * /
  get(cache, key) {
    if (cache.has(key)) {
      this.stats.hits++;
      return cache.get(key);
    }
    this.stats.misses++;
    return undefined;
  }

  /**
   * 设置缓存项
   * @param {Map} cache - 缓存Map
   * @param {string} key - 缓存键
   * @param {*} value - 缓存值
   * @param {number} ttl - 过期时间（毫秒）
   * /
  set(cache, key, value, ttl = 0) {
    cache.set(key, value);
    
    // 设置过期时间
    if (ttl > 0) {
      setTimeout(() => {
        cache.delete(key);
      }, ttl);
    }
  }

  /**
   * 获取缓存命中率
   * @returns {number} - 命中率
   * /
  getHitRate() {
    const total = this.stats.hits + this.stats.misses;
    return total > 0 ? this.stats.hits / total : 0;
  }

  /**
   * 清理特定类型缓存
   * @param {string} type - 缓存类型
   * /
  clear(type) {
    switch (type) {
      case 'element':
        this.importantElementCache.clear();
        this.ignoreElementCache.clear();
        break;
      case 'translation':
        this.translationCache.clear();
        break;
      case 'config':
        this.pageModeConfigCache.clear();
        break;
      case 'all':
        this.importantElementCache.clear();
        this.ignoreElementCache.clear();
        this.translationCache.clear();
        this.pageModeConfigCache.clear();
        this.stats.hits = 0;
        this.stats.misses = 0;
        break;
    }
  }
}

// 全局缓存管理器实例
const cacheManager = new CacheManager();

```

## 2. isImportantElement方法优化

## # 实现原理

优化后的`isImportantElement`方法能够根据页面模式判断元素的重要性，并使用缓存机制提高重复检测效率：

```javascript

/**
 * 判断元素是否为重要元素，需要根据页面模式进行优化判断
 * @param {HTMLElement} element - 需要判断的DOM元素
 * @param {string} pageMode - 当前页面模式（issues/pullRequests/wiki/search/codespaces等）
 * @returns {boolean} - 返回元素是否为重要元素
 * /
function isImportantElement(element, pageMode = 'default') {
  // 页面模式缓存键
  const cacheKey = `${pageMode}-${element.tagName}-${element.className}-${element.id}`;
  
  // 使用多级缓存管理器
  const cachedResult = cacheManager.get(cacheManager.importantElementCache, cacheKey);
  if (cachedResult !== undefined) {
    return cachedResult;
  }
  
  // 基于页面模式的元素跳过检查
  if (shouldSkipElementByPageMode(element, pageMode)) {
    cacheManager.set(cacheManager.importantElementCache, cacheKey, false, 60000); // 1分钟TTL
    return false;
  }
  
  let result = false;
  
  // 基础重要元素判断
  if (element.matches('h1, h2, h3, h4, h5, h6, p, li, td, th, a:not([href]), span:not([class])')) {
    result = true;
  }
  
  // 页面模式特定的重要元素判断
|  if (pageMode === 'issues' || pageMode === 'pullRequests') {|
    // Issues和PR页面特定规则
    if (element.matches('.js-issue-title, .js-comment-body, .timeline-comment-header, .review-comment-contents')) {
      result = true;
    }
  } else if (pageMode === 'wiki') {
    // Wiki页面特定规则
    if (element.matches('.wiki-content, .wiki-sidebar, .markdown-title')) {
      result = true;
    }
  } else if (pageMode === 'search') {
    // 搜索页面特定规则
    if (element.matches('.search-result, .code-list-item, .issue-list-item, .repository-list-item')) {
      result = true;
    }
  } else if (pageMode === 'codespaces') {
    // Codespaces页面特定规则
    if (element.matches('.codespace-card, .codespace-details, .codespace-status')) {
      result = true;
    }
  } else if (pageMode === 'copilot') {
    // Copilot页面特定规则
    if (element.matches('.copilot-suggestion, .copilot-chat, .ai-response')) {
      result = true;
    }
  } else if (pageMode === 'explore') {
    // Explore页面特定规则
    if (element.matches('.exploregrid-item, .trending-repo, .collection-card')) {
      result = true;
    }
  }
  
  // 存储到缓存，设置过期时间
  cacheManager.set(cacheManager.importantElementCache, cacheKey, result, 60000);
  return result;
}

```

## 2. shouldIgnoreElement方法优化

## # 实现原理

优化后的`shouldIgnoreElement`方法添加了页面模式特定的忽略规则和缓存支持：

```javascript

/**
 * 判断是否应该忽略某个元素，基于页面模式进行智能判断
 * @param {HTMLElement} element - 需要判断的DOM元素
 * @param {string} pageMode - 当前页面模式
 * @returns {boolean} - 返回是否应该忽略该元素
 * /
function shouldIgnoreElement(element, pageMode = 'default') {
  // 缓存机制
  const cacheKey = `${pageMode}-ignore-${element.tagName}-${element.className}-${element.id}`;
  const cachedResult = cacheManager.get(cacheManager.ignoreElementCache, cacheKey);
  if (cachedResult !== undefined) {
    return cachedResult;
  }
  
  // 基于页面模式的元素跳过检查
  if (shouldSkipElementByPageMode(element, pageMode)) {
    cacheManager.set(cacheManager.ignoreElementCache, cacheKey, true, 60000);
    return true;
  }
  
  // 基础忽略逻辑
  let result = false;
  if (element.matches('code, pre, script, style, textarea, input, select')) {
    result = true;
  }
  
  // 页面模式特定的忽略规则
  if (pageMode === 'codespaces') {
    // Codespaces页面特定忽略规则
    if (element.matches('.terminal-output, .code-editor, .file-content, .ide-status-bar')) {
      cacheManager.set(cacheManager.ignoreElementCache, cacheKey, true, 60000);
      return true;
    }
  } else if (pageMode === 'wiki') {
    // Wiki页面特定忽略规则
    if (element.matches('.markdown-body pre, .highlight, .language-*')) {
      cacheManager.set(cacheManager.ignoreElementCache, cacheKey, true, 60000);
      return true;
    }
  } else if (pageMode === 'search') {
    // 搜索页面特定忽略规则
    if (element.matches('.blob-code, .file-match, .search-code-content, .search-syntax')) {
      cacheManager.set(cacheManager.ignoreElementCache, cacheKey, true, 60000);
      return true;
    }
  } else if (pageMode === 'copilot') {
    // Copilot页面特定忽略规则
    if (element.matches('.copilot-code, .copilot-syntax, .token, .language-*')) {
      cacheManager.set(cacheManager.ignoreElementCache, cacheKey, true, 60000);
      return true;
    }
  }
  
  cacheManager.set(cacheManager.ignoreElementCache, cacheKey, result, 60000);
  return result;
}

```

## 3. 智能DOM监听优化

## # 实现原理

智能DOM监听通过节流（throttling）和防抖（debouncing）技术，结合页面模式特定的配置，实现高效的DOM变化检测：

```javascript

/**
 * 智能DOM监听器
 * /
class SmartDomMonitor {
  constructor(options = {}) {
    this.observer = null;
    this.throttleTimeout = null;
    this.debounceTimeout = null;
    this.mutationBuffer = [];
    this.isProcessing = false;
    
    // 默认配置
    this.options = {
      throttleDelay: 200,  // 节流延迟（毫秒）
      debounceDelay: 500,  // 防抖延迟（毫秒）
      batchSize: 100,      // 批处理大小
      ...options
    };
  }

  /**
   * 启动监听
   * @param {HTMLElement} target - 监听目标
   * @param {Function} callback - 回调函数
   * @param {string} pageMode - 页面模式
   * /
  start(target, callback, pageMode = 'default') {
    const config = this.getPageModeConfig(pageMode);
    
    this.observer = new MutationObserver((mutations) => {
      // 添加到缓冲区
      this.mutationBuffer = [...this.mutationBuffer, ...mutations];
      
      // 节流处理
      if (!this.throttleTimeout) {
        this.throttleTimeout = setTimeout(() => {
          this.processMutations(callback, pageMode);
          this.throttleTimeout = null;
        }, config.throttleDelay);
      }
      
      // 清除之前的防抖定时器
      if (this.debounceTimeout) {
        clearTimeout(this.debounceTimeout);
      }
      
      // 设置新的防抖定时器
      this.debounceTimeout = setTimeout(() => {
        this.processMutations(callback, pageMode, true);
      }, config.debounceDelay);
    });
    
    this.observer.observe(target, {
      childList: true,
      subtree: true,
      characterData: true,
      characterDataOldValue: true
    });
  }

  /**
   * 获取页面模式配置
   * @param {string} pageMode - 页面模式
   * @returns {Object} - 配置对象
   * /
  getPageModeConfig(pageMode) {
    const cachedConfig = cacheManager.get(cacheManager.pageModeConfigCache, pageMode);
    if (cachedConfig) {
      return cachedConfig;
    }
    
    // 页面模式特定配置
    const configs = {
      default: { throttleDelay: 200, debounceDelay: 500, batchSize: 100 },
      issues: { throttleDelay: 150, debounceDelay: 400, batchSize: 80 },
      pullRequests: { throttleDelay: 150, debounceDelay: 400, batchSize: 80 },
      wiki: { throttleDelay: 250, debounceDelay: 600, batchSize: 120 },
      search: { throttleDelay: 100, debounceDelay: 300, batchSize: 60 },
      codespaces: { throttleDelay: 300, debounceDelay: 800, batchSize: 150 },
      copilot: { throttleDelay: 100, debounceDelay: 300, batchSize: 50 }
    };
    
|    const config = configs[pageMode] || configs.default;|
    cacheManager.set(cacheManager.pageModeConfigCache, pageMode, config);
    return config;
  }

  /**
   * 处理DOM变更
   * @param {Function} callback - 回调函数
   * @param {string} pageMode - 页面模式
   * @param {boolean} isDebounce - 是否为防抖触发
   * /
  processMutations(callback, pageMode, isDebounce = false) {
|    if (this.isProcessing || this.mutationBuffer.length === 0) {|
      return;
    }
    
    this.isProcessing = true;
    
    // 批处理变更
    const config = this.getPageModeConfig(pageMode);
    const batch = this.mutationBuffer.splice(0, config.batchSize);
    
    try {
      // 过滤重要变更
      const importantMutations = batch.filter(mutation => 
        isContentRelatedMutation(mutation, pageMode)
      );
      
      if (importantMutations.length > 0) {
        callback(importantMutations, pageMode);
      }
    } catch (error) {
      // 错误处理
      console.error('处理DOM变更时出错:', error);
    } finally {
      this.isProcessing = false;
      
      // 如果还有未处理的变更，继续处理
      if (this.mutationBuffer.length > 0) {
        setTimeout(() => {
          this.processMutations(callback, pageMode);
        }, 0);
      }
    }
  }

  /**
   * 停止监听
   * /
  stop() {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
    
    if (this.throttleTimeout) {
      clearTimeout(this.throttleTimeout);
      this.throttleTimeout = null;
    }
    
    if (this.debounceTimeout) {
      clearTimeout(this.debounceTimeout);
      this.debounceTimeout = null;
    }
    
    this.mutationBuffer = [];
  }
}

// 全局智能DOM监听器实例
const smartDomMonitor = new SmartDomMonitor();

## 4. isContentRelatedMutation方法优化

## # 实现原理

优化后的`isContentRelatedMutation`方法实现了基于页面模式的内容变化判断：

```javascript

/**
 * 判断变更是否与内容相关，基于页面模式进行智能判断
 * @param {MutationRecord} mutation - DOM变更记录
 * @param {string} pageMode - 当前页面模式
 * @returns {boolean} - 返回变更是否与内容相关
 * /
function isContentRelatedMutation(mutation, pageMode = 'default') {
  // 字符数据变化处理
  if (mutation.type === 'characterData') {
|    const oldValue = mutation.oldValue || '';|
    const newValue = mutation.target.textContent;
    const textLength = Math.max(oldValue.length, newValue.length);
    const changeThreshold = getTextChangeThreshold(pageMode, textLength);
    
    // 使用页面模式特定的文本变化阈值
    return Math.abs(oldValue.length - newValue.length) >= changeThreshold;
  }
  
  // 属性变化处理
  if (mutation.type === 'attributes') {
    // 只关注特定属性变化
    if (['title', 'alt', 'aria-label'].includes(mutation.attributeName)) {
      return true;
    }
  }
  
  // 子节点变化处理
  if (mutation.type === 'childList') {
    // 基于页面模式的子节点过滤
|    if (pageMode === 'issues' || pageMode === 'pullRequests') {|
      // Issues和PR页面关注的变化
      return mutation.addedNodes.length > 0 && Array.from(mutation.addedNodes).some(node => {
        return node.nodeType === 1 && (node.matches('.comment, .timeline-item, .review-comment, .discussion-item'));
      });
    } else if (pageMode === 'wiki') {
      // Wiki页面关注的变化
      return mutation.addedNodes.length > 0 && Array.from(mutation.addedNodes).some(node => {
        return node.nodeType === 1 && (node.matches('.wiki-content, .page-history, .markdown-body'));
      });
    } else if (pageMode === 'codespaces') {
      // Codespaces页面关注的变化
      return mutation.addedNodes.length > 0 && Array.from(mutation.addedNodes).some(node => {
        return node.nodeType === 1 && (node.matches('.codespace-status, .terminal-output, .codespace-details'));
      });
    } else if (pageMode === 'search') {
      // 搜索页面关注的变化
      return mutation.addedNodes.length > 0 && Array.from(mutation.addedNodes).some(node => {
        return node.nodeType === 1 && (node.matches('.search-result, .pagination, .repo-list-item'));
      });
    } else if (pageMode === 'copilot') {
      // Copilot页面关注的变化
      return mutation.addedNodes.length > 0 && Array.from(mutation.addedNodes).some(node => {
        return node.nodeType === 1 && (node.matches('.copilot-suggestion, .ai-response, .chat-message'));
      });
    }
  }
  
  return false;
}

```javascript

## 4. detectImportantChanges方法优化

## # 实现原理

优化后的`detectImportantChanges`方法使用页面模式特定的性能配置和阈值：

```javascript

/**
 * 检测重要的DOM变更，触发翻译
 * @param {MutationRecord[]} mutations - DOM变更记录数组
 * @param {string} pageMode - 当前页面模式
 * @returns {boolean} - 返回是否检测到重要变更
 * /
function detectImportantChanges(mutations, pageMode = 'default') {
  // 页面模式存在性检查
|  const currentPageMode = pageMode || 'default';|
  
  // 性能参数
  const maxMutationCheck = getPageModeConfig(currentPageMode, 'maxMutationCheck', 100);
  
  // 如果变更太多，可能是大型渲染，直接触发翻译
  if (mutations.length > maxMutationCheck) {
    return true;
  }
  
  // 快速检查少量变化
  if (mutations.length < 5) {
    return mutations.some(mutation => {
      return isContentRelatedMutation(mutation, currentPageMode);
    });
  }
  
  // 详细检查子节点变化
  for (const mutation of mutations) {
    // 使用页面模式特定阈值
    const textChangeThreshold = getTextChangeThreshold(currentPageMode);
    
    // 处理子节点变化
    if (mutation.addedNodes.length > 0) {
      for (const node of mutation.addedNodes) {
        if (node.nodeType === 1) {
          // 使用页面模式参数
|          if (isImportantElement(node, currentPageMode) || |
              hasTranslatableChildren(node, currentPageMode)) {
            return true;
          }
        }
      }
    }
  }
  
  return false;
}

```javascript

## 🚀 辅助方法实现

## 1. getTextChangeThreshold方法

```javascript

/**
 * 获取基于页面模式的文本变化阈值
 * @param {string} pageMode - 当前页面模式
 * @param {number} textLength - 文本长度（可选）
 * @returns {number} - 返回文本变化阈值
 * /
function getTextChangeThreshold(pageMode = 'default', textLength = 0) {
  // 页面模式特定的阈值配置
  const thresholds = {
    issues: 2,       // Issues页面更敏感
    pullRequests: 2,
    wiki: 5,         // Wiki页面需要较大变化
    search: 3,       // 搜索结果适中敏感
    codespaces: 5,   // Codespaces页面较不敏感
    copilot: 1,      // Copilot页面非常敏感
    explore: 3,      // Explore页面适中敏感
    default: 3       // 默认阈值
  };
  
  // 获取对应页面模式的阈值
|  const baseThreshold = thresholds[pageMode] || thresholds.default;|
  
  // 根据文本长度动态调整阈值
  if (textLength > 1000) return baseThreshold + 3;
  if (textLength > 500) return baseThreshold + 2;
  if (textLength > 100) return baseThreshold + 1;
  
  return baseThreshold;
}

```javascript

## 2. shouldSkipElementByPageMode方法

```javascript

/**
 * 根据页面模式判断是否应该跳过某个元素
 * @param {HTMLElement} element - 需要判断的DOM元素
 * @param {string} pageMode - 当前页面模式
 * @returns {boolean} - 返回是否应该跳过该元素
 * /
function shouldSkipElementByPageMode(element, pageMode = 'default') {
  // 通用跳过规则
  if (element.nodeType !== 1) return true;
  if (element.hasAttribute('data-translated')) return true;
|  if (element.tagName === 'SCRIPT' || element.tagName === 'STYLE') return true;|
  
  // 页面模式特定跳过规则
  const skipRules = {
    issues: ['.timeline-comment-actions', '.discussion-sidebar-item', '.reaction-list', '.js-issue-vote'],
    pullRequests: ['.diffbar', '.file-header', '.code-review-tools', '.diff-stats'],
    wiki: ['.toc', '.page-edit-menu', '.wiki-footer', '.wiki-breadcrumb'],
    search: ['.search-filter', '.advanced-search', '.search-sort', '.filter-list'],
    codespaces: ['.terminal', '.ide-toolbar', '.file-tree', '.terminal-controls'],
    copilot: ['.copilot-editor', '.copilot-settings', '.token-line', '.copilot-status'],
    explore: ['.filter-bar', '.topic-list', '.pagination-container'],
    default: []
  };
  
  // 检查当前页面模式的跳过规则
|  const rules = skipRules[pageMode] || skipRules.default;|
  return rules.some(selector => element.matches(selector));
}

```javascript

## 📊 性能优化策略

## 1. 多级缓存机制

- **元素重要性缓存**：短期缓存，使用TTL机制自动失效
- **元素忽略缓存**：短期缓存，针对频繁访问的元素进行优化
- **翻译结果缓存**：持久化缓存，减少重复翻译计算
- **页面模式配置缓存**：会话级缓存，存储页面特定配置
- **缓存统计**：实时跟踪缓存命中率，优化缓存策略
- **智能缓存失效**：页面导航或模式切换时自动清理相关缓存

## 2. 页面模式优化

- **扩展页面模式支持**：新增Copilot、Explore等页面模式支持
- **定制化阈值**：为不同页面模式设置特定的文本变化阈值和性能参数
- **模式特定规则**：为各类页面实现定制化的元素判断和过滤规则
- **动态配置加载**：基于页面模式动态加载性能配置
- **模式检测优化**：使用URL路径和DOM特征进行快速准确的模式检测

## 3. 智能DOM监听优化

- **节流与防抖结合**：使用节流控制处理频率，使用防抖处理批量变更
- **批量处理机制**：按批次处理DOM变更，避免单次处理过多
- **优先级队列**：优先处理重要内容的变更
- **错误恢复机制**：监听过程中的错误不会影响整体功能
- **自适应配置**：根据页面复杂度动态调整监听参数

## 4. 错误恢复与稳定性保障

- **异常捕获**：所有关键方法都包含try-catch块
- **降级策略**：在极端情况下自动切换到更保守的处理模式
- **资源释放**：页面卸载时正确清理监听器和缓存
- **内存泄漏防护**：避免循环引用，及时清理不再需要的对象

## 🛡️ 使用建议

## 1. 页面模式识别

在调用相关方法时，应确保正确识别和传递当前页面模式：

```javascript

// 页面模式识别示例
function determinePageMode() {
  const path = window.location.pathname;
  
|  if (path.includes('/issues/') || path.includes('/pull/')) {|
    return path.includes('/pull/') ? 'pullRequests' : 'issues';
  } else if (path.includes('/wiki/')) {
    return 'wiki';
  } else if (path.includes('/search/')) {
    return 'search';
  } else if (path.includes('/codespaces/')) {
    return 'codespaces';
  }
  
  return 'default';
}

## 2. 性能优化配置建议

针对不同使用场景，可以调整以下性能配置参数以获得最佳体验：

```javascript

// 配置示例 - 适用于低配置设备
const lowEndConfig = {
  throttleDelay: 300,      // 增加节流延迟
  debounceDelay: 800,      // 增加防抖延迟
  batchSize: 50,           // 减少批处理大小
  cacheTTL: 30000          // 减少缓存过期时间
};

// 配置示例 - 适用于高配置设备
const highEndConfig = {
  throttleDelay: 100,      // 减少节流延迟
  debounceDelay: 300,      // 减少防抖延迟
  batchSize: 200,          // 增加批处理大小
  cacheTTL: 300000         // 增加缓存过期时间
};

// 配置示例 - 针对大型页面优化
const largePageConfig = {
  throttleDelay: 250,
  debounceDelay: 1000,     // 增加防抖延迟以减少频繁处理
  batchSize: 200,
  aggressiveCaching: true  // 启用更积极的缓存策略
};

// 应用配置
function applyPerformanceConfig(config) {
  Object.assign(smartDomMonitor.options, config);
  
  // 更新页面模式配置
  for (const pageMode in pageModes) {
    const pageConfig = cacheManager.get(cacheManager.pageModeConfigCache, pageMode);
    if (pageConfig) {
      Object.assign(pageConfig, {
        throttleDelay: config.throttleDelay,
        debounceDelay: config.debounceDelay,
        batchSize: config.batchSize
      });
    }
  }
}

// 使用示例
const pageMode = determinePageMode();

if (isImportantElement(element, pageMode)) {
  // 处理重要元素
}

```

## 2. 内置性能监控功能

插件内置了完整的性能监控功能，可以通过配置界面查看详细的性能数据：

## # 2.1 通过配置界面查看性能监控

1. 打开插件配置界面
2. 切换到"性能监控"选项卡
3. 查看以下性能指标：
   - 翻译启动时间
   - 处理元素数量
   - DOM操作时间
   - 网络请求时间
   - 缓存命中次数
   - 缓存未命中次数

## # 2.2 通过API获取性能数据

插件提供了以下性能监控API：

```javascript

// 获取基本性能统计数据
const basicStats = window.translationCore.getPerformanceStats();

console.log('基本性能统计:', basicStats);

// 获取高级性能数据（包含详细指标）
const advancedStats = window.translationCore.getPerformanceStats(true);

console.log('高级性能统计:', advancedStats);

// 导出性能数据（可保存为JSON文件）
const performanceData = window.translationCore.exportPerformanceData();

console.log('导出性能数据:', performanceData);

// 重置性能数据
window.translationCore.resetPerformanceData();

```

## # 2.3 性能数据结构

```javascript

// 基本性能统计
{
  totalTime: 1234.56, // 总耗时（毫秒）
  cacheHitRate: 0.85, // 缓存命中率
  avgDomOperationTime: 1.23, // 平均DOM操作时间
  avgNetworkRequestTime: 45.67 // 平均网络请求时间
}

// 高级性能统计
{
  translateStartTime: 1620000000000, // 翻译启动时间
  elementsProcessed: 100, // 处理元素数量
  domOperationTime: 123, // DOM操作总时间
  networkRequestTime: 456, // 网络请求总时间
  cacheHits: 85, // 缓存命中次数
  cacheMisses: 15, // 缓存未命中次数
  totalTime: 579, // 总耗时
  cacheHitRate: 0.85, // 缓存命中率
  avgDomOperationTime: 1.23, // 平均DOM操作时间
  avgNetworkRequestTime: 30.4 // 平均网络请求时间
}

// 导出性能数据
{
  timestamp: 1620000000000,
  pageMode: "default",
  stats: {
    // 高级性能统计数据
  },
  userAgent: "Mozilla/5.0...",
  browserLanguage: "zh-CN"
}

```

## # 2.4 性能监控事件

插件会自动记录以下性能事件：

```javascript

// 记录DOM操作事件
window.translationCore.recordPerformanceEvent('domOperation');

// 记录网络请求事件
window.translationCore.recordPerformanceEvent('networkRequest');

// 记录缓存命中事件
window.translationCore.recordPerformanceEvent('cacheHit');

// 记录缓存未命中事件
window.translationCore.recordPerformanceEvent('cacheMiss');

```

## 🔮 未来优化方向

1. **更精细的页面模式识别**：区分更多页面子类型，提供更精准的规则
2. **自适应阈值**：基于历史数据动态调整阈值，实现机器学习优化
3. **优先级队列**：实现元素处理优先级队列，优先处理重要内容
4. **Web Workers支持**：将复杂计算移至后台线程，避免阻塞主线程

## 📝 版本信息

- **文档版本**：1.8.172
- **最后更新**：2024-06-01
- **相关代码**：`pageMonitor.js`

- --

## 版本信息

{% include "_fragments/版本信息.md" %}
